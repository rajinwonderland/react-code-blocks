{"version":3,"sources":["../../../better-code-snippets/node_modules/refractor/lang/lisp.js"],"names":["lisp","Prism","simple_form","name","RegExp","primitive","pattern","symbol","par","language","heading","alias","comment","string","greedy","inside","argument","quoted-symbol","lisp-property","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","lisp-marker","rest","varform","forms","arglist","rest-vars","other-marker-vars","keys","util","clone","sublist","languages","elisp","emacs","module","exports","displayName","aliases"],"mappings":"2FAMA,SAAAA,EAAAC,IAGA,SAAAA,GAIA,SAAAC,EAAAC,GACA,OAAAC,OAAA,QAAAD,EAAA,gBAIA,SAAAE,EAAAC,GACA,OAAAF,OAAA,YAAAE,EAAA,cAMA,IAAAC,EAAA,yBAIAC,EAAA,QAIAC,EAAA,CAGAC,QAAA,CACAJ,QAAA,QACAK,MAAA,qBAEAC,QAAA,MACAC,OAAA,CACAP,QAAA,oBACAQ,QAAA,EACAC,OAAA,CACAC,SAAA,oBACAT,OAAAH,OAAA,IAAAG,EAAA,OAGAU,gBAAA,CACAX,QAAAF,OAAA,MAAAG,GACAI,MAAA,uBAEAO,gBAAA,CACAZ,QAAAF,OAAA,IAAAG,GACAI,MAAA,YAEAQ,OAAA,CACAb,QAAAF,OAAA,MAAAG,GACAI,MAAA,uBAEAS,QAAA,EACAd,QAAAF,OAAAI,EAAA,sJACAa,YAAA,GACO,CACPf,QAAAF,OAAAI,EAAA,gEACAa,YAAA,IAEAC,QAAA,CACAhB,QAAAJ,EAAA,WACAmB,YAAA,EACAV,MAAA,WAEAY,YAAA,CACAjB,QAAAJ,EAAA,eACAmB,YAAA,EACAV,MAAA,WAEAa,QAAA,CACAlB,QAAAD,EAAA,aACAgB,YAAA,GAEAI,OAAA,CACAnB,QAAAD,EAAA,yBACAgB,YAAA,GAEAK,OAAA,CACApB,QAAAF,OAAAI,EAAA,oCAAAD,GACAc,YAAA,EACAN,OAAA,CACAK,QAAA,aACAO,SAAAvB,OAAAG,KAGAqB,MAAA,CACAtB,QAAAF,OAAAI,EAAA,qCAAAD,EAAA,wBACAc,YAAA,EACAN,OAAA,CACAK,QAAA,kBAGAS,UAAA,KACAC,SAAA,CACAxB,QAAAF,OAAA,SAAAG,GACAc,YAAA,GAEAU,YAAA,SAGAC,OAAA,CACA1B,QAAAF,OAAAI,EAAA,qBAAAD,EAAA,aACAc,YAAA,EACAN,OAAA,CACAK,QAAA,UAGAS,UAAA,KACAE,YAAA,SAGAE,IAAA,CACA3B,QAAAF,OAAAI,EAAAD,GACAc,YAAA,GAEAU,YAAA,CACA,qBACA,CACAzB,QAAA,eACAe,YAAA,KAGAa,EAAA,CACAC,cAAA/B,OAzGA,2BA0GAgC,KAAA,CACApB,SAAA,CACAV,QAAAF,OAAAG,GACAI,MAAA,YAEA0B,QAAA,CACA/B,QAAAF,OAAAI,EAAAD,EAAA,2BACAc,YAAA,EACAN,OAAA,CACAF,OAAAJ,EAAAI,OACAW,QAAAf,EAAAe,QACAC,OAAAhB,EAAAgB,OACAlB,OAAAE,EAAAF,OACAwB,YAAA,WAKAO,EAAA,oBACAC,EAAA,CACAjC,QAAAF,OAAAI,EAAA,oBACAa,YAAA,EACAN,OAAA,CACAyB,YAAA,CACAlC,QAAAF,OAAA,qBAAAkC,GACAvB,OAAAmB,GAEAO,oBAAA,CACAnC,QAAAF,OAAA,wBAAAkC,GACAvB,OAAAmB,GAEAQ,KAAA,CACApC,QAAAF,OAAA,WAAAkC,EAAA,8BACAvB,OAAAmB,GAEAlB,SAAA,CACAV,QAAAF,OAAAG,GACAI,MAAA,YAEAoB,YAAA,SAGAtB,EAAA,OAAAM,OAAAc,UAAAU,EACA9B,EAAA,MAAAM,OAAAc,UAAA5B,EAAA0C,KAAAC,MAAAL,GACA9B,EAAA,MAAAM,OAAAc,UAAAd,OAAA8B,QAAAN,EACAtC,EAAA6C,UAAA9C,KAAAS,EACAR,EAAA6C,UAAAC,MAAAtC,EACAR,EAAA6C,UAAAE,MAAAvC,EACAR,EAAA6C,UAAA,cAAArC,EA5KA,CA6KGR,GApLHgD,EAAAC,QAAAlD,EACAA,EAAAmD,YAAA,OACAnD,EAAAoD,QAAA","file":"static/js/react-syntax-highlighter_languages_refractor_lisp.40835635.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = lisp;\nlisp.displayName = 'lisp';\nlisp.aliases = [];\n\nfunction lisp(Prism) {\n  ;\n\n  (function (Prism) {\n    // Functions to construct regular expressions\n    // simple form\n    // e.g. (interactive ... or (interactive)\n    function simple_form(name) {\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n    } // booleans and numbers\n\n\n    function primitive(pattern) {\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n\n\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+'; // symbol starting with & used in function arguments\n\n    var marker = '&' + symbol; // Open parenthesis for look-behind\n\n    var par = '(\\\\()';\n    var endpar = '(?=\\\\))'; // End the pattern with look-ahead space\n\n    var space = '(?=\\\\s)';\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [{\n        pattern: RegExp(par + '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' + space),\n        lookbehind: true\n      }, {\n        pattern: RegExp(par + '(?:for|do|collect|return|finally|append|concat|in|by)' + space),\n        lookbehind: true\n      }],\n      declare: {\n        pattern: simple_form('declare'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form('interactive'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive('(?:t|nil)'),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(par + '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' + symbol + '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [// open paren, brackets, and close paren\n      /(['`,]?\\(|[)\\[\\]])/, // cons\n      {\n        pattern: /(\\s)\\.(?=\\s)/,\n        lookbehind: true\n      }]\n    };\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      rest: {\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        varform: {\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n          lookbehind: true,\n          inside: {\n            string: language.string,\n            boolean: language.boolean,\n            number: language.number,\n            symbol: language.symbol,\n            punctuation: /[()]/\n          }\n        }\n      }\n    };\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n    var arglist = {\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    };\n    language['lambda'].inside.arguments = arglist;\n    language['defun'].inside.arguments = Prism.util.clone(arglist);\n    language['defun'].inside.arguments.inside.sublist = arglist;\n    Prism.languages.lisp = language;\n    Prism.languages.elisp = language;\n    Prism.languages.emacs = language;\n    Prism.languages['emacs-lisp'] = language;\n  })(Prism);\n}"],"sourceRoot":""}